from itertools import cycle
from bisect import bisect_left
import sys



#Node class definition
class Node(object):

    def __init__(self, value):
        self.value = value  #Splitting value
        self.left = None    #left child
        self.right = None   #right child
        Nodes.append(self)  #automatically append to Nodes array
    
    def getval(self):
        return self.value

    def getrightmost(self):   #Function to get the value of its rightmost child, will be called on the left child, to get splitting value
        if self.right == None:
            return self.value
        else:
            return self.right.getrightmost()
    
    def getleafs(self):      #Function to print the LEAF nodes of a node
        if self.left:
            self.left.getleafs()
        if self.right:
            self.right.getleafs()
        else:
            print (self.getval(),end=" ")


#Storing numbers in order, like in Task22
def Addnewnumbers(ListA,number):
    i = bisect_left(ListA, number)
    ListA.insert(i,number)

#Function to generate the tree, it recursively calls itself or a version of itself with the next nevel of nodes
#Return nothing, but creates the tree structure
def CreateNextLevel(ListA):
    NextLevelNodes = []    # Initialise next level nodes as empty
    if len(ListA) % 2 == 1:   #Check if the number of nodes on the level is odd, if it is store the last element, and leave it out of the for loop
        lastelement = ListA[len(ListA)-1]
        for i in range(0,len(ListA)-2,2):       #For every pair of nodes
            nextNode = ListA[i].getrightmost()  #Get the splitting value 
            nextNode = Node(nextNode)           #Make it a node
            nextNode.left = ListA[i]            #Connect them 
            nextNode.right = ListA[i+1]         #Connect them
            NextLevelNodes.append(nextNode)     #Store new node in next level of nodes

        NextLevelNodes.append(lastelement)      #Store the lonely one too
        
        if len(NextLevelNodes)>1:                   #If there are more than one nodes in the next level, we call "recursively"
            CreateNextLevelreverse(NextLevelNodes)  #But to keep the tree balanced, that is not to jagged, we call the reverse version of CreateNextLevel
        

    else:
        for i in range(0,len(ListA)-1,2):       #If number of nodes is even, we do the same, but we need not to leave the last element alone
            nextNode = ListA[i].getrightmost()
            nextNode = Node(nextNode)
            nextNode.left = ListA[i]
            nextNode.right = ListA[i+1]
            NextLevelNodes.append(nextNode)

        if len(NextLevelNodes)>1:               
            CreateNextLevel(NextLevelNodes)     #Since we have an even number of nodes next, we can call the same function.
      
#Modified version of CreateNextLevel, it is called, if we have an odd number of nodes in the next level,
# to keep the tree balanced it will iterate through the nodes backwards
#Returns nothing, but creates the tree structure
def CreateNextLevelreverse(ListA):
    NextLevelNodes = []
    if len(ListA) % 2 == 1:
        lastelement = ListA[0]
        for i in range(len(ListA)-1,0,-2):   #Only difference in for loop
            nextNode = ListA[i-1].getrightmost()
            nextNode = Node(nextNode)
            nextNode.right = ListA[i]
            nextNode.left = ListA[i-1]
            NextLevelNodes.append(nextNode)

        NextLevelNodes.append(lastelement)
        NextLevelNodes.reverse()
        
        if len(NextLevelNodes)>1:
            CreateNextLevel(NextLevelNodes)   #And the function call here, if the next level is odd as well, it calls its reverse, which is the original function
        

    else:
        for i in range(0,len(ListA)-1,2):
            nextNode = ListA[i].getrightmost()
            nextNode = Node(nextNode)
            nextNode.left = ListA[i]
            nextNode.right = ListA[i+1]
            NextLevelNodes.append(nextNode)

        if len(NextLevelNodes)>1:
            CreateNextLevelreverse(NextLevelNodes) 
        
#Find splitting node, it returns the root of the query
def FindSplitNode(Root,StartingPoint,EndPoint):
    X = Root.getval()
    while Root.right != None and (EndPoint <= X or StartingPoint > X):
        if EndPoint <= X:
            Root = Root.left
        else:
            Root = Root.right
        X = Root.getval()
    return Root


#Query, implemented as given, it prints the numbers between the endpoints, returns nothing
def OneDRangeQuery(Root,StartingPoint,EndPoint):
    Vsplit = FindSplitNode(Root,StartingPoint,EndPoint)
    #If Vsplit is a leaf, check if it should be returned
    if Vsplit.right == None:
        if ((Vsplit.getval() >= StartingPoint) and (Vsplit.getval() <= EndPoint)):
            print (Vsplit.getval(),end=" ")
            return 
    else:
        #If not, look at left subtree
        v = Vsplit.left
        while v.left != None:
            if StartingPoint <= v.getval():
                v.right.getleafs()
                v = v.left
            else:
                v = v.right
        if (v != None and (v.getval() >= StartingPoint) and (v.getval() <= EndPoint)):
                print (v.getval(),end=" ")

        #Then at right subtree
        v = Vsplit.right
        while v.left != None:
            if EndPoint >= v.getval():
                if v.left:
                    v.left.getleafs()
                v = v.right
            else:
                v = v.left
        if (v != None and (v.getval() >= StartingPoint) and (v.getval() <= EndPoint)):
                print (v.getval(),end=" ")
        
        return 
    

# Initialisation 
ListOfIntegers = [] # Array for the input numbers
Nodes = [] # Array to store created nodes

# Read the first line
FirstLine = sys.stdin.readline()
info = [int(i) for i in FirstLine.strip().split()]
NumberOfElements = info[0]
NumberOfQueries = info[1]

# Read numbers
for i in range(0,NumberOfElements):
    line = sys.stdin.readline()
    input_integer = int(line.strip())
    Addnewnumbers(ListOfIntegers,input_integer)


#Creating the tree
#creating a leaf for each input number
for element in ListOfIntegers:
    element = Node(element)
#Then call CreateNextLevel with the leafs, it generates the tree recursively
CreateNextLevel(Nodes)
#Finaly, the last created node, will be the root of the whole tree, so we store that
root = Nodes[len(Nodes)-1]

# Read queries
for i in range(0,NumberOfQueries):
    line = sys.stdin.readline()
    input_queries = [int(i) for i in line.strip().split()]
    OneDRangeQuery(root,input_queries[0],input_queries[1])
    print